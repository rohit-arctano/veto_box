// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file TestPublisherApp.cxx
 * This file contains the implementation of the publisher functions.
 *
 * This file was generated by the tool fastddsgen.
 */

 #include "TestPublisherApp.hpp"

 #include <condition_variable>
 #include <csignal>
 #include <stdexcept>
 #include <thread>
 #include <fastdds/dds/domain/DomainParticipantFactory.hpp>
 #include <fastdds/dds/log/Log.hpp>
 #include <fastdds/dds/publisher/DataWriter.hpp>
 #include <fastdds/dds/publisher/Publisher.hpp>
 #include <fastdds/dds/publisher/qos/DataWriterQos.hpp>
 #include <fastdds/dds/publisher/qos/PublisherQos.hpp>
 
 #include "TestPubSubTypes.hpp"
 
 using namespace eprosima::fastdds::dds;
 
 TestPublisherApp::TestPublisherApp(
     const int &domain_id)
     : factory_(nullptr), participant_(nullptr), publisher_(nullptr), topic_(nullptr), writer_(nullptr), type_(new TestPubSubType()), matched_(0), samples_sent_(0), stop_(false)
 {
     std::cout << "Initializing TestPublisherApp..." << std::endl;
 
     // Create the participant
     DomainParticipantQos participant_qos;
     participant_qos.name("TestParticipant");
     std::cout << "Setting participant QoS..." << std::endl;
 
     // Enable server discovery protocol
     participant_qos.wire_protocol().builtin.discovery_config.discoveryProtocol = 
         eprosima::fastdds::rtps::DiscoveryProtocol::SERVER;
     std::cout << "Enabled server discovery protocol." << std::endl;
 
     eprosima::fastdds::rtps::Locator_t remote_server_locator;
     remote_server_locator.kind = LOCATOR_KIND_UDPv4;
     eprosima::fastdds::rtps::IPLocator::setIPv4(remote_server_locator, "192.168.10.57"); // Subscriber IP
     remote_server_locator.port = 56543; // Example port
     participant_qos.wire_protocol().builtin.discovery_config.m_DiscoveryServers.push_back(remote_server_locator);
 
 
 
     // Define locator
     eprosima::fastdds::rtps::Locator_t locator;
     eprosima::fastdds::rtps::IPLocator::setIPv4(locator, "192.168.10.100");
     locator.port = 56542;
     std::cout << "Locator set to IP: 192.168.10.100, Port: 56542." << std::endl;
 
     // Set for both listening address and initial peer
     participant_qos.wire_protocol().builtin.metatrafficUnicastLocatorList.push_back(locator);
     participant_qos.wire_protocol().builtin.initialPeersList.push_back(locator);
     std::cout << "Locator added to metatrafficUnicastLocatorList and initialPeersList." << std::endl;
 
     // Optional: clear multicast
     participant_qos.wire_protocol().builtin.metatrafficMulticastLocatorList.clear();
     std::cout << "Cleared metatrafficMulticastLocatorList." << std::endl;
 
     // Create participant
     factory_ = DomainParticipantFactory::get_shared_instance();
     std::cout << "DomainParticipantFactory instance acquired." << std::endl;
 
     participant_ = factory_->create_participant(0, participant_qos);
     if (participant_ == nullptr)
     {
         throw std::runtime_error("Participant initialization failed");
     }
     std::cout << "Participant created successfully." << std::endl;
 
     // Register the type
     type_.register_type(participant_);
     std::cout << "Type registered successfully." << std::endl;
 
     // Create the publisher
     PublisherQos pub_qos = PUBLISHER_QOS_DEFAULT;
     publisher_ = participant_->create_publisher(pub_qos, nullptr, StatusMask::none());
     if (publisher_ == nullptr)
     {
         throw std::runtime_error("Test Publisher initialization failed");
     }
     std::cout << "Publisher created successfully." << std::endl;
 
     // Create the topic
     TopicQos topic_qos = TOPIC_QOS_DEFAULT;
     participant_->get_default_topic_qos(topic_qos);
     topic_ = participant_->create_topic("TestTopic", type_.get_type_name(), topic_qos);
     if (topic_ == nullptr)
     {
         throw std::runtime_error("Test Topic initialization failed");
     }
     std::cout << "Topic created successfully: TestTopic." << std::endl;
 
     // Create the data writer
     DataWriterQos writer_qos = DATAWRITER_QOS_DEFAULT;
     writer_qos.reliability().kind = ReliabilityQosPolicyKind::RELIABLE_RELIABILITY_QOS;
     writer_qos.durability().kind = DurabilityQosPolicyKind::TRANSIENT_LOCAL_DURABILITY_QOS;
     writer_ = publisher_->create_datawriter(topic_, writer_qos);
     if (writer_ == nullptr)
     {
         throw std::runtime_error("Test DataWriter initialization failed");
     }
     std::cout << "DataWriter created successfully." << std::endl;
 
     std::cout << "TestPublisherApp initialization complete." << std::endl;
 }
 
 TestPublisherApp::~TestPublisherApp()
 {
     if (nullptr != participant_)
     {
         // Delete DDS entities contained within the DomainParticipant
         participant_->delete_contained_entities();
 
         // Delete DomainParticipant
         factory_->delete_participant(participant_);
     }
 }
 
 void TestPublisherApp::on_publication_matched(
     DataWriter * /*writer*/,
     const PublicationMatchedStatus &info)
 {
     std::cout << "Test Publisher matched. " << info.total_count << std::endl;
     if (info.current_count_change == 1)
     {
         {
             std::lock_guard<std::mutex> lock(mutex_);
             matched_ = info.current_count;
         }
         std::cout << "Test Publisher matched." << std::endl;
         cv_.notify_one();
     }
     else if (info.current_count_change == -1)
     {
         {
             std::lock_guard<std::mutex> lock(mutex_);
             matched_ = info.current_count;
         }
         std::cout << "Test Publisher unmatched." << std::endl;
     }
     else
     {
         std::cout << info.current_count_change
                   << " is not a valid value for PublicationMatchedStatus current count change" << std::endl;
     }
 }
 
 void TestPublisherApp::run()
 {
     while (!is_stopped())
     {
         if (publish()) // Assuming publish() triggers an event
         {
             // Create an instance of KeyDataModule
             KeyDataModule obj(10, 20, 30);
 
             // Display object values
             obj.display();
 
             // Optional: If you need to send/process obj in some way
             processKeyData(obj);
         }
 
         // Wait for period or stop event
         std::unique_lock<std::mutex> period_lock(mutex_);
         cv_.wait_for(period_lock, std::chrono::milliseconds(period_ms_), [this]()
                      { return is_stopped(); });
     }
 }
 
 void TestPublisherApp::processKeyData(const KeyDataModule &data)
 {
     // Example processing or sending function
     std::cout << "Processing KeyDataModule: ";
     data.display();
 }
 
 bool TestPublisherApp::publish()
 {
     if (!writer_)
     {
         std::cerr << "Error: DataWriter is null!" << std::endl;
         return false;
     }
 
     // Create and send sample regardless of subscriber presence
     Test sample_;
     KeyDataModule data(10, 20, 30);
     std::ostringstream msg;
     msg << "k1:" << data.k1 << ",k2:" << data.k2 << ",k3:" << data.k3;
     sample_.msg(msg.str());
 
     std::cout << "Publishing sample: " << msg.str() << std::endl;
 
     ReturnCode_t ret;
     ret = (RETCODE_OK == writer_->write(&sample_));
     if (ret)
     {
         samples_sent_++;
         std::cout << "Sample sent successfully (Total: " << samples_sent_ << ")" << std::endl;
         return true;
     }
     else
     {
         std::cerr << "Failed to write sample: " << ret << std::endl;
         return false;
     }
 }
 
 bool TestPublisherApp::is_stopped()
 {
     return stop_.load();
 }
 
 void TestPublisherApp::stop()
 {
     stop_.store(true);
     cv_.notify_one();
 }