// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file TestPublisherApp.cxx
 * This file contains the implementation of the publisher functions.
 *
 * This file was generated by the tool fastddsgen.
 */

#include "TestPublisherApp.hpp"

#include <condition_variable>
#include <csignal>
#include <stdexcept>
#include <thread>
#include <fastdds/dds/domain/DomainParticipantFactory.hpp>
#include <fastdds/dds/log/Log.hpp>
#include <fastdds/dds/publisher/DataWriter.hpp>
#include <fastdds/dds/publisher/Publisher.hpp>
#include <fastdds/dds/publisher/qos/DataWriterQos.hpp>
#include <fastdds/dds/publisher/qos/PublisherQos.hpp>
#include <fastdds/rtps/common/Locator.hpp>
#include "TestPubSubTypes.hpp"

using namespace eprosima::fastdds::dds;

TestPublisherApp::TestPublisherApp(
        const int& domain_id)
    : factory_(nullptr)
    , participant_(nullptr)
    , publisher_(nullptr)
    , topic_(nullptr)
    , writer_(nullptr)
    , type_(new TestPubSubType())
    , matched_(0)
    , samples_sent_(0)
    , stop_(false)
    {
        // Get local IP address (replace with your actual IP)
        std::string local_ip = "192.168.1.100"; // Or use a method to get local IP
        
        // Create participant with specific QoS
        DomainParticipantQos pqos = PARTICIPANT_QOS_DEFAULT;
        pqos.name("Test_pub_participant");
        
        // Configure discovery to use specific IP
        pqos.wire_protocol().builtin.metatrafficUnicastLocatorList.clear();
        eprosima::fastdds::rtps::Locator_t meta_locator;
        meta_locator.kind = LOCATOR_KIND_UDPv4;
        meta_locator.port = 7400;  // Default discovery port
        eprosima::fastdds::rtps::IPLocator::setIPv4(meta_locator, local_ip);
        pqos.wire_protocol().builtin.metatrafficUnicastLocatorList.push_back(meta_locator);
        
        // Disable multicast for discovery
        pqos.wire_protocol().builtin.metatrafficMulticastLocatorList.clear();
    
        factory_ = DomainParticipantFactory::get_shared_instance();
        participant_ = factory_->create_participant(domain_id, pqos);
        
        // Register type
        type_.register_type(participant_);
    
        // Create publisher
        PublisherQos pub_qos = PUBLISHER_QOS_DEFAULT;
        publisher_ = participant_->create_publisher(pub_qos);
    
        // Create topic
        TopicQos topic_qos = TOPIC_QOS_DEFAULT;
        topic_ = participant_->create_topic("TestTopic", type_.get_type_name(), topic_qos);
    
        // Configure DataWriter QoS for visible traffic
        DataWriterQos writer_qos = DATAWRITER_QOS_DEFAULT;
        
        // Reliability settings
        writer_qos.reliability().kind = RELIABLE_RELIABILITY_QOS;
        writer_qos.durability().kind = TRANSIENT_LOCAL_DURABILITY_QOS;
        writer_qos.history().kind = KEEP_ALL_HISTORY_QOS;
        
        // Configure unicast locators using IPLocator
        writer_qos.endpoint().unicast_locator_list.clear();
        eprosima::fastdds::rtps::Locator_t uni_loc;
        uni_loc.kind = LOCATOR_KIND_UDPv4;
        uni_loc.port = 7412;  // Choose a specific port
        
        // Set IP using IPLocator methods
        if (!eprosima::fastdds::rtps::IPLocator::setIPv4(uni_loc, local_ip))
        {
            throw std::runtime_error("Failed to set IPv4 address");
        }
        writer_qos.endpoint().unicast_locator_list.push_back(uni_loc);
        
        // Clear multicast locators
        writer_qos.endpoint().multicast_locator_list.clear();
        
        // Force synchronous publishing
        writer_qos.publish_mode().kind = SYNCHRONOUS_PUBLISH_MODE;
        
        // Disable data sharing (which might use shared memory)
        writer_qos.data_sharing().off();
    
        // Create writer
        writer_ = publisher_->create_datawriter(topic_, writer_qos, this, StatusMask::all());
        
     
        // Print configured locators for debugging
        EPROSIMA_LOG_INFO(PUBLISHER, "Configured locators:");
        for (const auto& loc : writer_qos.endpoint().unicast_locator_list)
        {
            EPROSIMA_LOG_INFO(PUBLISHER, "  " << eprosima::fastdds::rtps::IPLocator::to_string(loc));
        }
    }
    

TestPublisherApp::~TestPublisherApp()
{
    if (nullptr != participant_)
    {
        // Delete DDS entities contained within the DomainParticipant
        participant_->delete_contained_entities();

        // Delete DomainParticipant
        factory_->delete_participant(participant_);
    }
}

void TestPublisherApp::on_publication_matched(
        DataWriter* /*writer*/,
        const PublicationMatchedStatus& info)
{
    if (info.current_count_change == 1)
    {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            matched_ = info.current_count;
        }
        std::cout << "Test Publisher matched." << std::endl;
        cv_.notify_one();
    }
    else if (info.current_count_change == -1)
    {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            matched_ = info.current_count;
        }
        std::cout << "Test Publisher unmatched." << std::endl;
    }
    else
    {
        std::cout << info.current_count_change
                  << " is not a valid value for PublicationMatchedStatus current count change" << std::endl;
    }
}

void TestPublisherApp::run()
{
    while (!is_stopped())
    {
        if (publish()) // Assuming publish() triggers an event
        {
            // Create an instance of KeyDataModule
            KeyDataModule obj(10, 20, 30);

            // Display object values
            // Optional: If you need to send/process obj in some way
            processKeyData(obj);
        }

        // Wait for period or stop event
        std::unique_lock<std::mutex> period_lock(mutex_);
        cv_.wait_for(period_lock, std::chrono::milliseconds(period_ms_), [this]()
                {
                    return is_stopped();
                });
    }
}

void TestPublisherApp::processKeyData(const KeyDataModule& data)
{
    // Example processing or sending function
    std::cout << "Processing KeyDataModule: ";
    data.display();
}

bool TestPublisherApp::publish()
{
    if (!writer_) {
        std::cerr << "Error: DataWriter is null!" << std::endl;
        return false;
    }
    bool ret = false;
    std::unique_lock<std::mutex> matched_lock(mutex_);
    cv_.wait(matched_lock, [&]() { return ((matched_ > 0) || is_stopped()); });

    if (!is_stopped())
    {
        // Create KeyDataModule object
        KeyDataModule data(10, 20, 30);
        
        // Convert to string
        std::ostringstream oss;
        oss << "k1:" << data.k1 << ",k2:" << data.k2 << ",k3:" << data.k3;
        
        // Create DDS message
        Test sample_;
        sample_.msg(oss.str());  // Set the serialized string
        
        // Send the message
        ret = (RETCODE_OK == writer_->write(&sample_));
        
        // Optional: Print what we're sending
        std::cout << "Sent: " << oss.str() << std::endl;
    }
    return ret;
}   

bool TestPublisherApp::is_stopped()
{
    return stop_.load();
}

void TestPublisherApp::stop()
{
    stop_.store(true);
    cv_.notify_one();
}